using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ACCRSourceGenerators;

[Generator]
public class StateGenerator : ISourceGenerator
{
    private const string _attribute = """
                                          using System;

                                          [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
                                          internal class StateAttribute : Attribute { }
                                          
                                          [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
                                          public class EnterAttribute : Attribute { }
                                          
                                          [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
                                          public class ExecuteAttribute : Attribute { }
                                          
                                          [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
                                          public class ExitAttribute : Attribute { }
                                          """;
	   
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("StateAttribute.g.cs", _attribute));
        context.RegisterForSyntaxNotifications(() => new StateSyntaxReceiver());        
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not StateSyntaxReceiver receiver)
            return;
        var coordinatorInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.ICoordinator");
        var stateInterface = context.Compilation.GetTypeByMetadataName("ACCR.Utils.IState");
        var enterEventHandler = context.Compilation.GetTypeByMetadataName("ACCR.Utils.EnterEventHandler");
        var executeEventHandler = context.Compilation.GetTypeByMetadataName("ACCR.Utils.ExecuteEventHandler");
        var exitEventHandler = context.Compilation.GetTypeByMetadataName("ACCR.Utils.ExitEventHandler");
        foreach (var classSymbol in receiver.States)
        {
            var enterMethods = receiver.EnterMethods[classSymbol];
            var executeMethods = receiver.ExecuteMethods[classSymbol];
            var exitMethods = receiver.ExitMethods[classSymbol];
            var generatedCode = $$"""
                                  // <auto-generated> //
                                  
                                  using System;
                                  using System.Collections.Generic;
                                  using ACCR;

                                  namespace {{classSymbol.ContainingNamespace?.ToDisplayString()}}
                                  {
                                      public partial class {{classSymbol.Name}} : {{stateInterface}} 
                                      {
                                           public {{coordinatorInterface}} Coordinator {get; set;}
                                           public event {{enterEventHandler}} OnEnter;
                                           public event {{executeEventHandler}} OnExecute;
                                           public event {{exitEventHandler}} OnExit;
                                           
                                           public {{classSymbol.Name}}({{coordinatorInterface}} coordinator) 
                                           {
                                               Coordinator = coordinator;
                                               {{GenerateEventInitializations(enterMethods, executeMethods, exitMethods)}}
                                           }
                                           
                                           public void Enter()
                                           {
                                               if(OnEnter is not null)
                                               {
                                                  OnEnter(this, EventArgs.Empty);
                                               }
                                           }
                                           
                                           public void Execute()
                                           {
                                               if(OnExecute is not null)
                                               {
                                                  OnExecute(this, EventArgs.Empty);
                                               }
                                           }
                                           
                                           public void Exit()
                                           {
                                               if(OnExit is not null)
                                               {
                                                  OnExit(this, EventArgs.Empty);
                                               }
                                           }
                                      }
                                  }
                                  """;

            context.AddSource($"{classSymbol.Name}.g.cs", generatedCode);
        }
    }

    private static string GenerateEventInitializations(List<IMethodSymbol> enterMethods, List<IMethodSymbol> executeMethods, List<IMethodSymbol> exitMethods)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var method in enterMethods)
        {
            if(!firstLine) 
                builder = Utils.Indent(builder, 3);
            else 
                firstLine = false;
            builder.AppendLine($"OnEnter += {method.Name};");
        }
        foreach (var method in executeMethods)
        {
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"OnExecute += {method.Name};");
        }
        foreach (var method in exitMethods)
        {
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"OnExit += {method.Name};");
        }
        return builder.ToString();
        return builder.ToString();
    }

    private class StateSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> States { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IMethodSymbol>> EnterMethods { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IMethodSymbol>> ExecuteMethods { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IMethodSymbol>> ExitMethods { get; } = [];
        
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax)
                return;
            if(context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                return;
            if (!classSymbol.GetAttributes()
                    .Any(ad => ad.AttributeClass?.ToDisplayString() == "StateAttribute")) return;
            {
                States.Add(classSymbol);
                EnterMethods[classSymbol] = new List<IMethodSymbol>();
                ExecuteMethods[classSymbol] = new List<IMethodSymbol>();
                ExitMethods[classSymbol] = new List<IMethodSymbol>();

                foreach (var method in classSymbol.GetMembers().OfType<IMethodSymbol>())
                {
                    if (method.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "EnterAttribute"))
                    {
                        EnterMethods[classSymbol].Add(method);
                    }
                    if (method.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "ExecuteAttribute"))
                    {
                        ExecuteMethods[classSymbol].Add(method);
                    }
                    if (method.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "ExitAttribute"))
                    {
                        ExitMethods[classSymbol].Add(method);
                    }
                }
            }
        }
    }
}
