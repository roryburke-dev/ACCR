using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ACCRSourceGenerators;


[Generator]
public class StateGenerator : ISourceGenerator
{
    // Generated Attribute
    private const string _attribute = """
                                          using System;

                                          [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
                                          internal class StateAttribute : Attribute { }
                                          
                                          [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
                                          public class EnterAttribute : Attribute { }
                                          
                                          [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
                                          public class ExecuteAttribute : Attribute { }
                                          
                                          [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
                                          public class ExitAttribute : Attribute { }
                                          """;
	   
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("StateAttribute.g.cs", _attribute));
        context.RegisterForSyntaxNotifications(() => new StateSyntaxReceiver());        
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not StateSyntaxReceiver receiver)
            return;
        var stateInterface = context.Compilation.GetTypeByMetadataName("Utils.IState");
        var coordinatorInterface = context.Compilation.GetTypeByMetadataName("ACCR.ICoordinator");
        foreach (var classSymbol in receiver.States)
        {
            var enterMethods = receiver.EnterMethods[classSymbol];
            var executeMethods = receiver.ExecuteMethods[classSymbol];
            var exitMethods = receiver.ExitMethods[classSymbol];
            string generatedCode = $$"""
                                     // <auto-generated/
                                     using System;
                                     using System.Collections.Generic;
                                     using ACCR;
                                     using Utils;
                                     
                                     namespace {{classSymbol.ContainingNamespace?.ToDisplayString()}}
                                     {
                                         public partial class {{classSymbol.Name}} : {{stateInterface}} 
                                         {
                                              public {{coordinatorInterface}} Coordinator {get; set;}
                                              public event EnterEventHandler OnEnter;
                                              public event ExecuteEventHandler OnExecute;
                                              public event ExitEventHandler OnExit;
                                              
                                              public {{classSymbol.Name}}({{coordinatorInterface}} coordinator) 
                                              {
                                                  Coordinator = coordinator;
                                                  {{GenerateEventInitializations(enterMethods, executeMethods, exitMethods)}}
                                              }
                                              
                                              public void Enter()
                                              {
                                                  if(OnEnter is not null)
                                                  {
                                                     OnEnter(this, EventArgs.Empty);
                                                  }
                                              }
                                              
                                              public void Execute()
                                              {
                                                  if(OnExecute is not null)
                                                  {
                                                     OnExecute(this, EventArgs.Empty);
                                                  }
                                              }
                                              
                                              public void Exit()
                                              {
                                                  if(OnExit is not null)
                                                  {
                                                     OnExit(this, EventArgs.Empty);
                                                  }
                                              }
                                         }
                                     }
                                     """;

            context.AddSource($"{classSymbol.Name}.g.cs", generatedCode);
        }
    }
    
    public string GenerateEventInitializations(List<IMethodSymbol> enterMethods, List<IMethodSymbol> executeMethods, List<IMethodSymbol> exitMethods)
    {
        var builder = new StringBuilder();
        foreach (var method in enterMethods)
        {
            builder.AppendLine($"OnEnter += {method.Name};");
        }
        foreach (var method in executeMethods)
        {
            builder.AppendLine($"OnExecute += {method.Name};");
        }
        foreach (var method in exitMethods)
        {
            builder.AppendLine($"OnExit += {method.Name};");
        }
        return builder.ToString();
    }

    private class StateSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> States { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IMethodSymbol>> EnterMethods { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IMethodSymbol>> ExecuteMethods { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IMethodSymbol>> ExitMethods { get; } = [];
        
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax)
                return;
            if(context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                return;
            if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "StateAttribute"))
            {
                States.Add(classSymbol);
                EnterMethods[classSymbol] = new List<IMethodSymbol>();
                ExecuteMethods[classSymbol] = new List<IMethodSymbol>();
                ExitMethods[classSymbol] = new List<IMethodSymbol>();

                foreach (var method in classSymbol.GetMembers().OfType<IMethodSymbol>())
                {
                    if (method.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "EnterAttribute"))
                    {
                        EnterMethods[classSymbol].Add(method);
                    }
                    if (method.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "ExecuteAttribute"))
                    {
                        ExecuteMethods[classSymbol].Add(method);
                    }
                    if (method.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "ExitAttribute"))
                    {
                        ExitMethods[classSymbol].Add(method);
                    }
                }
            }
        }
    }
}
