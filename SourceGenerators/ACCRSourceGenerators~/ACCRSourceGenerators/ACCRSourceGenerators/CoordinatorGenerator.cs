using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ACCRSourceGenerators;

[Generator]
public class CoordinatorGenerator : ISourceGenerator
{
    private const string _attribute = """
                                          using System;

                                          [AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = false)]
                                          internal class CoordinatorAttribute : Attribute { }
                                          """;
	   
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("CoordinatorAttribute.g.cs", _attribute));
        context.RegisterForSyntaxNotifications(() => new CoordinatorSyntaxReceiver());        
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not CoordinatorSyntaxReceiver receiver)
            return;
        var coordinatorInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.ICoordinator");
        var containerInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.IContainer");
        var aspectInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.IAspect");
        var stateInterface = context.Compilation.GetTypeByMetadataName("ACCR.Utils.IState");
        var infoInterface = context.Compilation.GetTypeByMetadataName("ACCR.Utils.Info");
        foreach (var classSymbol in receiver.Coordinators)
        {
            var resolvers = receiver.Resolvers[classSymbol];
            var containers = receiver.Containers[classSymbol];
            var states = receiver.States[classSymbol];
            var generatedCode = $$"""
                                  // <auto-generated> //
                                  
                                  using System;
                                  using System.Collections.Generic;
                                  using System.Linq;
                                  using UnityEngine;
                                  
                                  namespace {{classSymbol.ContainingNamespace?.ToDisplayString()}}
                                  {
                                      public partial class {{classSymbol.Name}} : {{coordinatorInterface}}
                                      {
                                          public Dictionary<string, {{containerInterface}}> Containers { get; set; }
                                          public Dictionary<Type,{{stateInterface}}> States { get; set; }
                                          public {{stateInterface}}? CurrentState { get; set; }
                                          public {{stateInterface}}? PreviousState { get; set; }
                                          
                                          public void Initialize(Dictionary<string, {{containerInterface}}> containers)
                                          {
                                             Containers = containers;
                                             States = new Dictionary<Type, {{stateInterface}}>();
                                             {{GenerateContainerInitializations(containers)}}
                                             {{GenerateResolverInitializations(resolvers)}}
                                             {{GenerateStateInitializations(states)}}
                                          }
                                          
                                          public void AddContainer(string id, {{containerInterface}} container)
                                          {
                                             container.Initialize(id);
                                             if(Containers.ContainsKey(id)) return;
                                             Containers.Add(id, container);
                                          }
                                          
                                          public T GetContainer<T>(string id) where T : {{containerInterface}}
                                          {
                                             return (T)Containers[id];
                                          }
                                      
                                          public List<T> GetContainers<T>() where T : {{containerInterface}}
                                          {
                                             var list = new List<T>();
                                             foreach (var container in Containers.Values)
                                             {
                                                list.Add((T)container);
                                             }
                                             return list;
                                          }
                                          
                                          public Dictionary<string, {{containerInterface}}> GetAllContainers() 
                                          {
                                             return Containers;                  
                                          }
                                          
                                          public {{stateInterface}} GetCurrentState()
                                          {
                                              return CurrentState;
                                          }
                                          
                                          public {{stateInterface}} GetPreviousState()
                                          {
                                              return PreviousState;
                                          }
                                          
                                          public void ChangeState({{stateInterface}} newState)
                                          {
                                              CurrentState?.Exit();
                                              PreviousState = CurrentState;
                                              CurrentState = newState;
                                              CurrentState?.Enter();
                                          }
                                          
                                          public void UpdateState()
                                          {
                                              CurrentState?.Execute();
                                          }
                                          
                                          public {{infoInterface}}<T> OnNotify<T>({{infoInterface}}<T> info)
                                          {
                                              return info switch
                                              {
                                                  {{infoInterface}}<string>                         stringInfo          => OnNotify(stringInfo)         as {{infoInterface}}<T>,
                                                  {{infoInterface}}<int>                            intInfo             => OnNotify(intInfo)            as {{infoInterface}}<T>,
                                                  {{infoInterface}}<bool>                           boolInfo            => OnNotify(boolInfo)           as {{infoInterface}}<T>,
                                                  {{infoInterface}}<{{aspectInterface}}>            aspectInfo          => OnNotify(aspectInfo)         as {{infoInterface}}<T>,
                                                  {{infoInterface}}<List<{{aspectInterface}}>>      aspectsInfo         => OnNotify(aspectsInfo)        as {{infoInterface}}<T>, 
                                                  {{infoInterface}}<{{containerInterface}}>         containerInfo       => OnNotify(containerInfo)      as {{infoInterface}}<T>,
                                                  {{infoInterface}}<List<{{containerInterface}}>>   containersInfo      => OnNotify(containersInfo)     as {{infoInterface}}<T>,
                                                  {{infoInterface}}<{{coordinatorInterface}}>       coordinatorInfo     => OnNotify(coordinatorInfo)    as {{infoInterface}}<T>,
                                                  {{infoInterface}}<List<{{coordinatorInterface}}>> coordinatorsInfo    => OnNotify(coordinatorsInfo)   as {{infoInterface}}<T>,
                                                  {{infoInterface}}<{{stateInterface}}>             stateInfo           => OnNotify(stateInfo)          as {{infoInterface}}<T>,
                                                  {{infoInterface}}<List<{{stateInterface}}>>       statesInfo          => OnNotify(statesInfo)         as {{infoInterface}}<T>,
                                                  _ => info
                                              };
                                          }
                                      }
                                  }
                                  """;

            context.AddSource($"{classSymbol.Name}.g.cs", generatedCode);
        }
    }

    private static string GenerateStateInitializations(List<IFieldSymbol> states)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in states)
        {
            if(!firstLine) 
                builder = Utils.Indent(builder, 3);
            else 
                firstLine = false;
            builder.AppendLine($"{field.Name} = new {field.Type}(this);");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"States[typeof({field.Type})] = {field.Name};");
        }
        return builder.ToString();
    }
    
    private static string GenerateContainerInitializations(List<IFieldSymbol> containers)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in containers)
        {
            var fieldName = field.Name.Split('.').LastOrDefault();
            var id = fieldName?.Replace("_", "").ToUpper();
            if(!firstLine) 
                builder = Utils.Indent(builder, 3);
            else 
                firstLine = false;
            builder.AppendLine($"{fieldName} = ({field.Type})Containers[\"{id}\"];");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"{fieldName}.Initialize(\"{id}\");");
        }
        return builder.ToString();
    }


    private static string GenerateResolverInitializations(List<IFieldSymbol> resolvers)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in resolvers)
        {
            if(!firstLine) 
                builder = Utils.Indent(builder, 3);
            else 
                firstLine = false;
            builder.AppendLine($"{field.Name} = new {field.Type}();");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"{field.Name}.Initialize();");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"{field.Name}.Register(this);");
        }
        return builder.ToString();
    }

    private class CoordinatorSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> Coordinators { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IFieldSymbol>> States { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IFieldSymbol>> Resolvers { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IFieldSymbol>> Containers { get; } = [];
        
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax) 
                return;
            if(context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol) 
                return;
            if (!classSymbol.GetAttributes().Any(attributeData => attributeData.AttributeClass?.ToDisplayString() == "CoordinatorAttribute")) 
                return;
            
            Coordinators.Add(classSymbol);
            States[classSymbol] = [];
            Resolvers[classSymbol] = [];
            Containers[classSymbol] = [];
            
            foreach (var field in classSymbol.GetMembers().OfType<IFieldSymbol>())
            {
                if (field.GetAttributes().Any(attributeData => attributeData.AttributeClass?.ToDisplayString() == "StateAttribute")) 
                    States[classSymbol].Add(field);
            }
            
            foreach (var field in classSymbol.GetMembers().OfType<IFieldSymbol>())
            {
                if (field.GetAttributes().Any(attributeData => attributeData.AttributeClass?.ToDisplayString() == "ResolverAttribute")) 
                    Resolvers[classSymbol].Add(field);
            }
                            
            foreach (var field in classSymbol.GetMembers().OfType<IFieldSymbol>())
            {
                if (field.GetAttributes().Any(attributeData => attributeData.AttributeClass?.ToDisplayString() == "ContainerAttribute")) 
                    Containers[classSymbol].Add(field);
            } 
        }
    }
}