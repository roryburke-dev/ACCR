using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ACCRSourceGenerators;

[Generator]
public class AspectGenerator : ISourceGenerator 
{
    private const string _attribute = """
                                          using System;
                                          
                                          [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Field)]
                                          internal class AspectAttribute : System.Attribute { }
                                          
                                          [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
                                          public class SOAttribute : Attribute { }
                                          """;
    
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("AspectAttribute.g.cs", _attribute));
        context.RegisterForSyntaxNotifications(() => new AspectSyntaxReceiver());        
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not AspectSyntaxReceiver receiver)
            return;
        var aspectInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.IAspect");
        var containerInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.IContainer");
        foreach (var structSymbol in receiver.Aspects)
        {
            var fields = receiver.Fields[structSymbol];
            var generatedCode = $$"""
                                   // <auto-generated> //
                                   
                                   #nullable enable
                                   
                                   using System;
                                   using System.Runtime.InteropServices;
                                   using System.Collections.Generic;
                                   using UnityEngine;
                                   using ACCR;

                                   namespace {{structSymbol.ContainingNamespace?.ToDisplayString()}}
                                   {
                                       [StructLayout(LayoutKind.Auto)]
                                       public partial struct {{structSymbol.Name}} : {{aspectInterface}} 
                                       {
                                           public {{containerInterface}} Container {get; set;}
                                           
                                           public void Initialize<T>({{containerInterface}} container, T data)
                                           {
                                               InitializeContainer(container);
                                               InitializeScriptableObject(data);
                                           }
                                           
                                           public void InitializeContainer({{containerInterface}} container)
                                           {
                                               Container = container;
                                           }
                                           
                                           public void InitializeScriptableObject<T>(T data)
                                           {
                                               if(data is not so{{structSymbol.Name}} soData) return;
                                               {{GenerateScriptableObjectFieldInitializations(fields)}}    
                                           }
                                           
                                           public T GetContainer<T>() where T : class, {{containerInterface}}
                                           {
                                               return (T)Container;
                                           }
                                           
                                           {{GenerateMutatorsAndAccessors(fields, structSymbol)}}
                                       }
                                       
                                       [CreateAssetMenu(fileName = "{{structSymbol.Name}}Data", menuName = "ScriptableObjects/{{structSymbol.Name}}")]
                                       public class so{{structSymbol.Name}} : ScriptableObject
                                       {
                                           {{GenerateScriptableObjectFields(fields)}}
                                       }
                                   }
                                   """;
            context.AddSource($"{structSymbol.Name}.g.cs", generatedCode);
        }
    }

    private static string GenerateMutatorsAndAccessors(List<IFieldSymbol> fields, INamedTypeSymbol aspect)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in fields)
        {
            var fieldName = field.Name;
            fieldName = fieldName.Replace("_", "");
            fieldName = char.ToUpper(fieldName[0]) + fieldName.Substring(1);
            if(!firstLine) 
                builder = Utils.Indent(builder, 2);
            else 
                firstLine = false;
            builder.AppendLine($"public {aspect} Set{fieldName}({field.Type} value)");
            builder = Utils.Indent(builder, 2);
            builder.AppendLine("{");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"{field.Name} = value;");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine("var copy = this;");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine("return copy;");
            builder = Utils.Indent(builder, 2);
            builder.AppendLine("}");
            builder.AppendLine();
            builder = Utils.Indent(builder, 2);
            builder.AppendLine($"public {field.Type} Get{fieldName}()");
            builder = Utils.Indent(builder, 2);
            builder.AppendLine("{");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"return {field.Name};");
            builder = Utils.Indent(builder, 2);
            builder.AppendLine("}");
            builder.AppendLine();
        }
        return builder.ToString();
    }

    private static string GenerateScriptableObjectFields(List<IFieldSymbol> fields)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in fields)
        {
            if(!firstLine) 
                builder = Utils.Indent(builder, 2);
            else 
                firstLine = false;
            builder.AppendLine($"public {field.Type} {field.Name.Replace("_", "")};");
        }
        return builder.ToString();
    }

    private static string GenerateScriptableObjectFieldInitializations(List<IFieldSymbol> fields)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in fields)
        {
            if(!firstLine) 
                builder = Utils.Indent(builder, 3);
            else 
                firstLine = false;
            builder.AppendLine($"{field.Name} = soData.{field.Name.Replace("_", "")};");
        }
        return builder.ToString();
    }

    private class AspectSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> Aspects { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IFieldSymbol>> Fields { get; } = [];

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not StructDeclarationSyntax  { AttributeLists.Count: > 0 } structDeclarationSyntax) return;
            if(context.SemanticModel.GetDeclaredSymbol(structDeclarationSyntax) is not INamedTypeSymbol structSymbol) return;
            if (!structSymbol.GetAttributes()
                    .Any(ad => ad.AttributeClass?.ToDisplayString() == "AspectAttribute")) return;
            {
                Aspects.Add(structSymbol);
                Fields[structSymbol] = [];
                foreach (var field in structSymbol.GetMembers().OfType<IFieldSymbol>())
                {
                    if (field.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "SOAttribute")) Fields[structSymbol].Add(field);
                }
            }
        }
    }
}