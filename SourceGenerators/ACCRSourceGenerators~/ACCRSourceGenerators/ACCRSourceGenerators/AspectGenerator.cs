using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ACCRSourceGenerators;

[Generator]
public class AspectGenerator : ISourceGenerator 
{
    private const string _attribute = """
                                          using System;
                                          
                                          [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Field)]
                                          internal class AspectAttribute : System.Attribute { }
                                          
                                          [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
                                          public class SOAttribute : Attribute { }
                                          """;
    
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("AspectAttribute.g.cs", _attribute));
        context.RegisterForSyntaxNotifications(() => new AspectSyntaxReceiver());        
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not AspectSyntaxReceiver receiver)
            return;
        var aspectInterface = context.Compilation.GetTypeByMetadataName("ACCR.IAspect");
        var containerInterface = context.Compilation.GetTypeByMetadataName("ACCR.IContainer");
        foreach (var structSymbol in receiver.Aspects)
        {
            var fields = receiver.Fields[structSymbol];
            string generatedCode = $$$"""
                                      // <auto-generated/
                                      using System;
                                      using System.Collections.Generic;
                                      using UnityEngine;
                                      using ACCR;
                                      
                                      namespace {{{structSymbol.ContainingNamespace?.ToDisplayString()}}}
                                      {
                                          public partial struct {{{structSymbol.Name}}} : {{{aspectInterface}}} 
                                          {
                                              public {{{containerInterface}}} Container {get; set;}
                                              
                                              public void Initialize<T>({{{containerInterface}}} container, T data)
                                              {
                                                  InitializeContainer(container);
                                                  InitializeScriptableObject(data);
                                              }
                                              
                                              public void InitializeContainer({{{containerInterface}}} container)
                                              {
                                          	     Container = container;
                                              }
                                              
                                              public void InitializeScriptableObject<T>(T data)
                                              {
                                                  if(data is not so{{{structSymbol.Name}}} soData) return;
                                                  {{{GenerateFieldInitializations(fields)}}}    
                                              }
                                              
                                              {{{GenerateMutatorsAndAccessors(fields, structSymbol)}}}
                                          }
                                          
                                          [CreateAssetMenu(fileName = "{{{structSymbol.Name}}}Data", menuName = "ScriptableObjects/{{{structSymbol.Name}}}")]
                                          public class so{{{structSymbol.Name}}} : ScriptableObject
                                          {
                                              {{{GenerateScriptableObjectFields(fields)}}}
                                          }
                                      }
                                      """;
            context.AddSource($"{structSymbol.Name}.g.cs", generatedCode);
        }
    }

    private string GenerateMutatorsAndAccessors(List<IFieldSymbol> fields, INamedTypeSymbol aspect)
    {
        var builder = new StringBuilder();
        foreach (var field in fields)
        {
            var fieldName = field.Name;
            fieldName = fieldName.Replace("_", "");
            fieldName = char.ToUpper(fieldName[0]) + fieldName.Substring(1);
            builder.AppendLine($"public {aspect} Set{fieldName}({field.Type} value)");
            builder.AppendLine("{");
            builder.AppendLine("var copy = this;");
            builder.AppendLine($"copy.{field.Name} = value;");
            builder.AppendLine("return copy;");
            builder.AppendLine("}");
            builder.AppendLine($"public {field.Type} Get{fieldName}()");
            builder.AppendLine("{");
            builder.AppendLine($"return {field.Name};");
            builder.AppendLine("}");
        }
        return builder.ToString();
    }

    private string GenerateScriptableObjectFields(List<IFieldSymbol> fields)
    {
        var builder = new StringBuilder();
        foreach (var field in fields)
        {
            builder.AppendLine($"public {field.Type} {field.Name};");
        }
        return builder.ToString();
    }

    private string GenerateFieldInitializations(List<IFieldSymbol> fields)
    {
        var builder = new StringBuilder();
        foreach (var field in fields)
        {
            builder.AppendLine($"{field.Name} = soData.{field.Name};");
        }
        return builder.ToString();
    }

    private class AspectSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> Aspects { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IFieldSymbol>> Fields { get; } = [];

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not StructDeclarationSyntax  { AttributeLists.Count: > 0 } structDeclarationSyntax) return;
            if(context.SemanticModel.GetDeclaredSymbol(structDeclarationSyntax) is not INamedTypeSymbol structSymbol) return;
            if (structSymbol.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "AspectAttribute"))
            {
                Aspects.Add(structSymbol);
                Fields[structSymbol] = new List<IFieldSymbol>();
                foreach (var field in structSymbol.GetMembers().OfType<IFieldSymbol>())
                {
                    if (field.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "SOAttribute")) Fields[structSymbol].Add(field);
                }
            }
        }
    }
}