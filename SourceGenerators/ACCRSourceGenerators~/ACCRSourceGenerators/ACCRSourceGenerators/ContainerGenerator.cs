using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ACCRSourceGenerators;

[Generator]
public class ContainerGenerator : ISourceGenerator
{
    // Generated Attribute
    private const string _attribute = """
                                          using System;

                                          [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
                                          internal class ContainerAttribute : Attribute { }
                                          """;
    
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("ContainerAttribute.g.cs", _attribute));
        context.RegisterForSyntaxNotifications(() => new ContainerSyntaxReceiver());        
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not ContainerSyntaxReceiver receiver)
            return;
        var aspectInterface = context.Compilation.GetTypeByMetadataName("ACCR.IAspect");
        var containerInterface = context.Compilation.GetTypeByMetadataName("ACCR.IContainer");
        foreach (var classSymbol in receiver.Containers)
        {
            var aspects = receiver.Aspects[classSymbol];
            string generatedCode = $$"""
                                     // <auto-generated/
                                     using System;
                                     using System.Collections.Generic;
                                     using ACCR;
                                     
                                     public partial class {{classSymbol.Name}} : {{containerInterface}}
                                     {
                                         public Dictionary<Type, {{aspectInterface}}> Aspects {get; set;}
                                         {{GenerateAspectScriptableObjectFields(aspects)}}
                                         
                                         public void Initialize()
                                         {
                                            Aspects = new Dictionary<Type, {{aspectInterface}}>();
                                            {{GenerateAspectInitializations(aspects)}}
                                         }
                                         
                                         public T GetAspect<T>() where T : struct
                                         {
                                            return Aspects.ContainsKey(typeof(T)) ? (T)Aspects[typeof(T)] : default(T);
                                         }
                                         
                                         public Dictionary<Type, {{aspectInterface}}> GetAllAspects()
                                         {
                                            return Aspects;
                                         }
                                         
                                         {{GenerateAspectUpdaters(aspects)}}
                                     }
                                     """;
            context.AddSource($"{classSymbol.Name}.g.cs", generatedCode);
        }
    }

    private string GenerateAspectUpdaters(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        foreach (var field in aspects)
        {
            var fieldName = field.Name;
            fieldName = fieldName.Replace("_", "");
            fieldName = char.ToUpper(fieldName[0]) + fieldName.Substring(1);
            builder.AppendLine($"public void Update{fieldName}({field.Type} value)");
            builder.AppendLine("{");
            builder.AppendLine($"this.{field.Name} = value;");
            builder.AppendLine($"Aspects[typeof({field.Type})] = value;");
            builder.AppendLine("}");
        }
        return builder.ToString();
    }

    private string GenerateAspectScriptableObjectFields(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        foreach (var field in aspects)
        {
            builder.AppendLine($"public so{field.Type} {field.Name}Data;");
        }
        return builder.ToString();
    }

    private string GenerateAspectInitializations(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        foreach (var field in aspects)
        {
            builder.AppendLine($"this.{field.Name} = new {field.Type}();");
            builder.AppendLine($"this.{field.Name}.Initialize<so{field.Type}>(this, {field.Name}Data);");
            builder.AppendLine($"Aspects[typeof({field.Type})] = {field.Name};");
        }
        return builder.ToString();
    }

    private class ContainerSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> Containers { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IFieldSymbol>> Aspects { get; } = [];
        
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax)
                return;
            if(context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                return;
            if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "ContainerAttribute"))
            {
                Containers.Add(classSymbol);
                Aspects[classSymbol] = new List<IFieldSymbol>();

                foreach (var field in classSymbol.GetMembers().OfType<IFieldSymbol>())
                {
                    if (field.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "AspectAttribute"))
                    {
                        Aspects[classSymbol].Add(field);
                    }
                }
            }
        }
    }
}