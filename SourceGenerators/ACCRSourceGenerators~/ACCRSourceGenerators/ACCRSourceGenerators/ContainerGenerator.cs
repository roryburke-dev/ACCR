using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ACCRSourceGenerators;

[Generator]
public class ContainerGenerator : ISourceGenerator
{
    private const string _attribute = """
                                          using System;

                                          [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
                                          internal class ContainerAttribute : Attribute { }
                                          """;
    
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("ContainerAttribute.g.cs", _attribute));
        context.RegisterForSyntaxNotifications(() => new ContainerSyntaxReceiver());        
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not ContainerSyntaxReceiver receiver)
            return;
        var aspectInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.IAspect");
        var containerInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.IContainer");
        foreach (var classSymbol in receiver.Containers)
        {
            var aspects = receiver.Aspects[classSymbol];
            var generatedCode = $$"""
                                  // <auto-generated> //
                                  using System;
                                  using System.Collections.Generic;
                                  using ACCR;

                                  namespace {{classSymbol.ContainingNamespace?.ToDisplayString()}}
                                  {
                                      public partial class {{classSymbol.Name}} : {{containerInterface}}
                                      {
                                          public string Id {get; set;}
                                          public Dictionary<Type, {{aspectInterface}}> Aspects {get; set;}
                                          {{GenerateAspectScriptableObjectFields(aspects)}}
                                          
                                          public void Initialize(string id)
                                          {
                                              Id = id;
                                              Aspects = new Dictionary<Type, {{aspectInterface}}>();
                                              {{GenerateAspectFieldInitializations(aspects)}}
                                          }
                                          
                                          public T GetAspect<T>() where T : struct
                                          {
                                             return Aspects.ContainsKey(typeof(T)) ? (T)Aspects[typeof(T)] : default(T);
                                          }
                                          
                                          public Dictionary<Type, {{aspectInterface}}> GetAllAspects()
                                          {
                                             return Aspects;
                                          }
                                          
                                          public void UpdateAspect({{aspectInterface}} aspect)
                                          {
                                            {{GenerateAspectUpdateSwitchStatement(aspects)}}  
                                          }
                                          
                                          {{GenerateAspectUpdaters(aspects)}}
                                      }
                                  }
                                  """;
            context.AddSource($"{classSymbol.Name}.g.cs", generatedCode);
        }
    }

    private static string GenerateAspectUpdateSwitchStatement(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        builder.AppendLine("switch(aspect.GetType().ToString())");
        builder = Utils.Indent(builder, 3);
        builder.AppendLine("{");
        foreach (var field in aspects)
        {
            var fieldName = field.Name.Replace("_", "");
            fieldName = char.ToUpper(fieldName[0]) + fieldName.Substring(1);
            builder = Utils.Indent(builder, 4);
            builder.AppendLine($"case \"{field.Type}\":");
            builder = Utils.Indent(builder, 5);
            builder.AppendLine($"Update{fieldName}(({field.Type})aspect);");
            builder = Utils.Indent(builder, 5);
            builder.AppendLine("break;");
        }
        builder = Utils.Indent(builder, 3);
        builder.AppendLine("}");
        return builder.ToString();
    }

    private static string GenerateAspectUpdaters(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in aspects)
        {
            var fieldName = field.Name.Replace("_", "");
            fieldName = char.ToUpper(fieldName[0]) + fieldName.Substring(1);
            if(!firstLine) 
                builder = Utils.Indent(builder, 2);
            else 
                firstLine = false;
            builder.AppendLine($"public void Update{fieldName}({field.Type} value)");
            builder = Utils.Indent(builder, 2);
            builder.AppendLine("{");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"{field.Name} = value;");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"Aspects[typeof({field.Type})] = value;");
            builder = Utils.Indent(builder, 2);
            builder.AppendLine("}");
        }
        return builder.ToString();
    }

    private static string GenerateAspectScriptableObjectFields(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in aspects)
        {
            var fieldTypeName = field.Type.ToDisplayString().Split('.').LastOrDefault();
            if (fieldTypeName == null) continue;
            var fieldType = field.Type.ToDisplayString().Substring(0,field.Type.ToDisplayString().Length - fieldTypeName.Length);
            if(!firstLine) 
                builder = Utils.Indent(builder, 2);
            else 
                firstLine = false;
            builder.AppendLine($"public {fieldType}so{fieldTypeName} {field.Name}Data;");
        }
        return builder.ToString();
    }

    private static string GenerateAspectFieldInitializations(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in aspects)
        {
            var fieldTypeName = field.Type.ToDisplayString().Split('.').LastOrDefault();
            if (fieldTypeName != null)
            {
                var fieldType = field.Type.ToDisplayString().Substring(0,field.Type.ToDisplayString().Length - fieldTypeName.Length);
                if(!firstLine) 
                    builder = Utils.Indent(builder, 3);
                else 
                    firstLine = false;
                builder.AppendLine($"{field.Name} = new {field.Type}();");
                builder = Utils.Indent(builder, 3);
                builder.AppendLine($"{field.Name}.Initialize<{fieldType}so{fieldTypeName}>(this, {field.Name}Data);");
            }
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"Aspects[typeof({field.Type})] = {field.Name};");
        }
        return builder.ToString();
    }

    private class ContainerSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> Containers { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IFieldSymbol>> Aspects { get; } = [];
        
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax)
                return;
            if(context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                return;
            if (!classSymbol.GetAttributes()
                    .Any(ad => ad.AttributeClass?.ToDisplayString() == "ContainerAttribute")) return;
            {
                Containers.Add(classSymbol);
                Aspects[classSymbol] = new List<IFieldSymbol>();

                foreach (var field in classSymbol.GetMembers().OfType<IFieldSymbol>())
                {
                    if (field.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "AspectAttribute"))
                    {
                        Aspects[classSymbol].Add(field);
                    }
                }
            }
        }
    }
}