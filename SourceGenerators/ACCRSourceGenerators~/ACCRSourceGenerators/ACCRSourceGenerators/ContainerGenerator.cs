using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ACCRSourceGenerators;

[Generator]
public class ContainerGenerator : ISourceGenerator
{
    private const string _attribute = """
                                          using System;

                                          [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
                                          internal class ContainerAttribute : Attribute { }
                                          """;
    
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("ContainerAttribute.g.cs", _attribute));
        context.RegisterForSyntaxNotifications(() => new ContainerSyntaxReceiver());        
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not ContainerSyntaxReceiver receiver)
            return;
        var aspectInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.IAspect");
        var containerInterface = context.Compilation.GetTypeByMetadataName("ACCR.ACCR.IContainer");
        
        List<IFieldSymbol> _aspects = [];
        foreach (var field in receiver.Aspects.Values.SelectMany(aspects => aspects.Where(field => !_aspects.Contains(field))))
        {
            _aspects.Add(field);
        }

        var generatedEnum = $$"""
                              // <auto-generated> //
                              
                              using System;
                              
                              namespace ACCR.Generated
                              {
                                  public enum Aspect
                                  {
                                      {{GenerateAspectEnum(_aspects)}}
                                  }
                              }
                              """;
        
        context.AddSource("AspectEnum.g.cs", generatedEnum);

        foreach (var classSymbol in receiver.Containers)
        {
            var aspects = receiver.Aspects[classSymbol];
            var generatedCode = $$"""
                                  // <auto-generated> //
                                  
                                  using System;
                                  using System.Collections.Generic;
                                  using ACCR;
                                  using ACCR.Generated;

                                  namespace {{classSymbol.ContainingNamespace?.ToDisplayString()}}
                                  {
                                      public partial class {{classSymbol.Name}} : {{containerInterface}}
                                      {
                                          public int Id {get; set;}
                                          public Dictionary<int, {{aspectInterface}}> Aspects {get; set;}
                                          {{GenerateAspectScriptableObjectFields(aspects)}}
                                          
                                          public void Initialize(int id)
                                          {
                                              Id = id;
                                              Aspects = new Dictionary<int, {{aspectInterface}}>();
                                              {{GenerateAspectFieldInitializations(aspects)}}
                                          }
                                          
                                          public T GetAspect<T>() where T : struct, {{aspectInterface}}
                                          {
                                              foreach(var aspect in Aspects)
                                              {
                                                  if(aspect.Value is T) return (T)aspect.Value;
                                              }
                                              return default(T);
                                          }
                                          
                                          public T GetAspect<T>(int id) where T : struct, {{aspectInterface}}
                                          {
                                              return Aspects.ContainsKey(id) ? (T)Aspects[id] : default(T);
                                          }
                                          
                                          public bool GetAspect<T>(out T aspect) where T : struct, {{aspectInterface}}
                                          {
                                              foreach(var _aspect in Aspects)
                                              {
                                                  if(_aspect.Value is T)
                                                  {
                                                      aspect = (T)_aspect.Value;
                                                      return true;
                                                  } 
                                              }
                                              aspect = default(T);
                                              return false;
                                          }
                                          
                                          public bool GetAspect<T>(int id, out T aspect) where T : struct, {{aspectInterface}}
                                          {
                                              {{aspectInterface}} _aspect;
                                              if (Aspects.TryGetValue(id, out _aspect)) 
                                              {
                                                aspect = (T)_aspect;
                                                return true;
                                              }
                                              aspect = default(T);
                                              return false;
                                          }
                                          
                                          public List<T> GetAspects<T>() where T : struct, {{aspectInterface}}
                                          {
                                              List<T> aspects = new List<T>();
                                              foreach (var aspect in Aspects)
                                              {
                                                  if (aspect.Value is T) aspects.Add((T)aspect.Value);
                                              }
                                              return aspects;
                                          }
                                          
                                          public void UpdateAspect({{aspectInterface}} aspect)
                                          {
                                              {{GenerateAspectUpdateSwitchStatement(aspects)}}  
                                          }
                                          
                                          {{GenerateAspectUpdaters(aspects)}}
                                      }
                                  }
                                  """;
            
            context.AddSource($"{classSymbol.Name}.g.cs", generatedCode);
        }
    }
    
    private static string GenerateAspectEnum(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        List<string> aspectEnum = [];
        foreach (var field in aspects.Where(field => !aspectEnum.Contains(field.Name.Split('.').LastOrDefault()?.Replace("_", "").ToUpper())))
        {
            if(!firstLine) 
                builder = Utils.Indent(builder, 2);
            else 
                firstLine = false;
            aspectEnum.Add(field.Name.Split('.').LastOrDefault()?.Replace("_", "").ToUpper());
            builder.AppendLine($"{field.Name.Split('.').LastOrDefault()?.Replace("_", "").ToUpper()},");
        }
        return builder.ToString();
    }

    private static string GenerateAspectUpdateSwitchStatement(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        builder.AppendLine("switch(aspect.Id)");
        builder = Utils.Indent(builder, 3);
        builder.AppendLine("{");
        foreach (var field in aspects)
        {
            var fieldName = field.Name.Replace("_", "");
            fieldName = char.ToUpper(fieldName[0]) + fieldName.Substring(1);
            builder = Utils.Indent(builder, 4);
            builder.AppendLine($"case (int)Aspect.{field.Name.Split('.').LastOrDefault()?.Replace("_", "").ToUpper()}:");
            builder = Utils.Indent(builder, 5);
            builder.AppendLine($"Update{fieldName}(({field.Type})aspect);");
            builder = Utils.Indent(builder, 5);
            builder.AppendLine("break;");
        }
        builder = Utils.Indent(builder, 3);
        builder.AppendLine("}");
        return builder.ToString();
    }

    private static string GenerateAspectUpdaters(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in aspects)
        {
            var fieldName = field.Name.Replace("_", "");
            fieldName = char.ToUpper(fieldName[0]) + fieldName.Substring(1);
            if(!firstLine) 
                builder = Utils.Indent(builder, 2);
            else 
                firstLine = false;
            builder.AppendLine($"public void Update{fieldName}({field.Type} value)");
            builder = Utils.Indent(builder, 2);
            builder.AppendLine("{");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"{field.Name} = value;");
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"Aspects[(int)Aspect.{field.Name.Split('.').LastOrDefault()?.Replace("_", "").ToUpper()}] = value;");
            builder = Utils.Indent(builder, 2);
            builder.AppendLine("}");
        }
        return builder.ToString();
    }

    private static string GenerateAspectScriptableObjectFields(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in aspects)
        {
            var fieldTypeName = field.Type.ToDisplayString().Split('.').LastOrDefault();
            if (fieldTypeName == null) continue;
            var fieldType = field.Type.ToDisplayString().Substring(0,field.Type.ToDisplayString().Length - fieldTypeName.Length);
            if(!firstLine) 
                builder = Utils.Indent(builder, 2);
            else 
                firstLine = false;
            builder.AppendLine($"public {fieldType}so{fieldTypeName} {field.Name}Data;");
        }
        return builder.ToString();
    }

    private static string GenerateAspectFieldInitializations(List<IFieldSymbol> aspects)
    {
        var builder = new StringBuilder();
        var firstLine = true;
        foreach (var field in aspects)
        {
            var fieldTypeName = field.Type.ToDisplayString().Split('.').LastOrDefault();
            if (fieldTypeName != null)
            {
                var fieldType = field.Type.ToDisplayString().Substring(0,field.Type.ToDisplayString().Length - fieldTypeName.Length);
                if(!firstLine) 
                    builder = Utils.Indent(builder, 3);
                else 
                    firstLine = false;
                builder.AppendLine($"{field.Name} = new {field.Type}();");
                builder = Utils.Indent(builder, 3);
                builder.AppendLine($"{field.Name}.Initialize<{fieldType}so{fieldTypeName}>((int)Aspect.{field.Name.Split('.').LastOrDefault()?.Replace("_", "").ToUpper()},this, {field.Name}Data);");
            }
            builder = Utils.Indent(builder, 3);
            builder.AppendLine($"Aspects[(int)Aspect.{field.Name.Split('.').LastOrDefault()?.Replace("_", "").ToUpper()}] = {field.Name};");
        }
        return builder.ToString();
    }

    private class ContainerSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> Containers { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IFieldSymbol>> Aspects { get; } = [];
        
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax)
                return;
            if(context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                return;
            if (!classSymbol.GetAttributes()
                    .Any(ad => ad.AttributeClass?.ToDisplayString() == "ContainerAttribute")) return;
            {
                Containers.Add(classSymbol);
                Aspects[classSymbol] = new List<IFieldSymbol>();

                foreach (var field in classSymbol.GetMembers().OfType<IFieldSymbol>())
                {
                    if (field.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "AspectAttribute"))
                    {
                        Aspects[classSymbol].Add(field);
                    }
                }
            }
        }
    }
}