using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ACCRSourceGenerators;

[Generator]
public class ResolverGenerator : ISourceGenerator
{
    // Generated Attribute
    private const string _attribute = """
                                          using System;

                                          [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
                                          internal class ResolverAttribute : Attribute { }
                                          
                                          [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
                                          public class ActionAttribute : Attribute { }
                                          """;
	   
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i => i.AddSource("ResolverAttribute.g.cs", _attribute));
        context.RegisterForSyntaxNotifications(() => new ResolverSyntaxReceiver());        
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not ResolverSyntaxReceiver receiver)
            return;
        var resolverInterface = context.Compilation.GetTypeByMetadataName("ACCR.IResolver");
        var aspectInterface = context.Compilation.GetTypeByMetadataName("ACCR.IAspect");
        var observerInterface = context.Compilation.GetTypeByMetadataName("Utils.IObserver");
        var infoInterface = context.Compilation.GetTypeByMetadataName("Utils.Info");
        foreach (var classSymbol in receiver.Resolvers)
        {
            var actions = receiver.Actions[classSymbol];
            string generatedCode = $$"""
                                     // <auto-generated/
                                     using System;
                                     using System.Collections.Generic;
                                     using ACCR;
                                     
                                     namespace {{classSymbol.ContainingNamespace?.ToDisplayString()}}
                                     {
                                         public partial class {{classSymbol.Name}} : {{resolverInterface}} 
                                         {
                                             public event ResolverEventHandler OnFire;
                                             public List<{{aspectInterface}}> Aspects {get; set;}
                                             public List<{{observerInterface}}> Observers { get; set; }
                                             
                                             public void Initialize()
                                             {
                                                 Aspects = new List<{{aspectInterface}}>();
                                                 Observers = new List<{{observerInterface}}>();
                                                 {{GenerateActionInitializations(actions)}}
                                             }
                                             
                                             public void AddAspect({{aspectInterface}} aspect)
                                             {
                                                 Aspects.Add(aspect);
                                             }
                                             
                                             public void AddAspects(List<{{aspectInterface}}> aspects)
                                             {
                                                 foreach (var aspect in aspects)
                                                 {
                                                    Aspects.Add(aspect);
                                                 }
                                             }
                                             
                                             public void RemoveAspect({{aspectInterface}} aspect)
                                             {
                                                Aspects.Remove(aspect);
                                             }
                                             
                                             public void Register({{observerInterface}} observer)
                                             {
                                                Observers.Add(observer);
                                             }
                                             
                                             public void Unregister({{observerInterface}} observer)
                                             {
                                                Observers.Remove(observer);
                                             }
                                             
                                             public void Fire<T>({{infoInterface}}<T> info)
                                             {
                                                 foreach (var aspect in Aspects)
                                                 {
                                                     if(OnFire is not null)
                                                     {
                                                        OnFire(this, EventArgs.Empty, aspect, info);
                                                     }
                                                 }
                                                 Notify(info);
                                             }
                                             
                                             public void Notify<T>({{infoInterface}}<T> info)
                                             {
                                                foreach (var observer in Observers)
                                                {
                                                    observer.OnNotify(info);
                                                }
                                             }
                                         }
                                     }
                                     """;
            context.AddSource($"{classSymbol.Name}.g.cs", generatedCode);
        }
    }

    private string GenerateActionInitializations(List<IMethodSymbol> actions)
    {
        var builder = new StringBuilder();
        foreach (var method in actions)
        {
            builder.AppendLine($"OnFire += {method.Name};");
        }
        return builder.ToString();
    }

    private class ResolverSyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> Resolvers { get; } = [];
        public Dictionary<INamedTypeSymbol, List<IMethodSymbol>> Actions { get; } = [];
        
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax)
                return;
            if(context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                return;
            if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "ResolverAttribute"))
            {
                Resolvers.Add(classSymbol);
                Actions[classSymbol] = new List<IMethodSymbol>();

                foreach (var method in classSymbol.GetMembers().OfType<IMethodSymbol>())
                {
                    if (method.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "ActionAttribute"))
                    {
                        Actions[classSymbol].Add(method);
                    }
                }
            }
        }
    }
}